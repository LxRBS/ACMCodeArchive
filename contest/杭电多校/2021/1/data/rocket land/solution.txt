每次添加一个点，求以该点为圆心半径为r的圆中的权值和。
圆是比较难进行维护的一种形状，std选择了使用kd tree近似暴力地来进行维护，在随机数据下可以良好的呈现近似O(n√n)的复杂度（可以通过造数据卡掉）。std使用了离线做法，不需要对树进行重构，通过标记点是否已经被加入树来对查询进行剪枝优化。本来想尝试卡掉动态加点的需要对树进行平衡的做法，不过实际跑下来并没有太大的差距，具体可以查看std，两种做法都写了一份。