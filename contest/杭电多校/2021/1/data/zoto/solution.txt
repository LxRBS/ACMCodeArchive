首先来看一个子问题：给一个数组，初始所有位置全是0，每次单点加一或减一，询问区间有多少个位置不为0。也许你很快会给出一个修改O(logn)查询O(logn)的优秀做法。那么如果强制规定修改O(1)，查询能做到什么效率？我们去考虑分块，维护两个数组num[i]和sum[i]分别维护第i位置上的值，以及第i块内的值不为0的位置个数。那么每次单点修改只需要修改num[i]和sum[i/block_size]两个位置的值，然后查询的时候需要O（sqrtn）效率的去查询区间所覆盖的完整块的值以及区间两端散块的值（散块值可以没有）。这显然是一个修改O(1)，查询O（sqrtn）的做法。
然后考虑这个题，我们发现可以用莫队去维护询问的区间，即x坐标。y(fx)维度单独拎出来就变成了上述子问题。我们会神奇的发现，这样的复杂度是：O（n*sqrt(n)*1+m*1*sqrt(n)）的，莫队单次修改时O(sqrtn)的复杂度遇上了值域上O(1)的修改，莫队单次查询时O(1)的复杂度遇上了值域查询时O（sqrt(n)）的复杂度。