{"scoring":null,"notes":"The example input and the example output are illustrated below.\r\n\\\\\r\n\\includegraphics{hard.1}\r\n\\\\\r\n\\\\\r\n\\includegraphics{hard.2}","legend":"You are given a set of $n$ segments on a line $[L_i; R_i]$. All $2n$ segment endpoints are pairwise distinct integers.\r\n\r\nThe set is \\emph{laminar}~--- any two segments are either disjoint or one of them contains the other.\r\n\r\nChoose a non-empty subsegment $[l_i, r_i]$ with integer endpoints in each segment ($L_i \\le l_i < r_i \\le R_i$) in such a way that no two subsegments intersect (they are allowed to have common endpoints though) and the sum of their lengths ($\\sum_{i=1}^n r_i - l_i$) is maximized.","authorLogin":"elizarov","language":"english","timeLimit":3000,"output":"On the first line, output the maximum possible sum of subsegment lengths.\r\n\r\nOn the $i$-th of the next $n$ lines, output two integers $l_i$ and $r_i$ ($L_i \\le l_i < r_i \\le R_i$), denoting the chosen subsegment of the $i$-th segment.","inputFile":"stdin","outputFile":"stdout","input":"The first line contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^3$)~--- the number of segments.\r\n\r\nThe $i$-th of the next $n$ lines contains two integers $L_i$ and $R_i$ ($0 \\le L_i < R_i \\le 10^9$)~--- the endpoints of the $i$-th segment.\r\n\r\nAll the given $2n$ segment endpoints are distinct. The set of segments is laminar.","authorName":"Roman Elizarov","sampleTests":[{"output":"7\r\n3 6\r\n2 3\r\n7 9\r\n6 7\r\n","input":"4\r\n1 10\r\n2 3\r\n5 9\r\n6 7\r\n","inputFile":"example.01","outputFile":"example.01.a"}],"name":"Hard Optimization","interaction":null,"memoryLimit":536870912,"tutorial":"A \\emph{laminar} set of segments clearly forms a forest-like structure: outer segments (not contained in any other ones) are the roots of the trees, segments that are only contained in outer segments are their children, and so on, recursively.\r\n\r\nRecovering the tree structure can be done with sorting and stack. Go through all segments in increasing order of $L_i$, and keep a stack which describes the current rightmost path in the tree. For each segment, pop the segments that are fully on the left of it from the stack. After that, we know that the top of the stack is the parent of this segment (if the stack is empty, this segment is the root of a new tree), and we push the segment onto the stack.\r\n\r\nOn these trees, we are going to use dynamic programming. Suppose we have found the optimal choice of subsegments for the children $s_1, s_2, \\ldots, s_k$ of a particular segment $i$. Then we can greedily pick the longest empty"}